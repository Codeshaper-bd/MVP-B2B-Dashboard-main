parameters:
  - name: BICEP_FILE_LOCATION
    default: "IaC/build-pipeline/bicep"
  - name: ARTIFACT_NAME
    default: "drop"

steps:
  - script: |

      # Detect if this is a PR build
      if [ -n "$(System.PullRequest.SourceBranch)" ]; then
        PR_SOURCE_BRANCH=$(echo "$(System.PullRequest.SourceBranch)" | sed 's|refs/heads/||')
        PR_TARGET_BRANCH=$(echo "$(System.PullRequest.TargetBranch)" | sed 's|refs/heads/||')

        echo "ðŸ”€ Pull Request detected!"
        echo "PR Source Branch: $PR_SOURCE_BRANCH"
        echo "PR Destination (Target) Branch: $PR_TARGET_BRANCH"

        # Use target branch for environment selection
        DEST_BRANCH="$PR_TARGET_BRANCH"
      else
        # Regular build triggered by a merge or direct push
        DEST_BRANCH=$(echo "$(Build.SourceBranch)" | sed 's|refs/heads/||')
        echo "ðŸ“Œ Regular build detected. Destination Branch: $DEST_BRANCH"
      fi

      # Define path to the parameters folder
      CURRENT_DIR=$(pwd)
      PARAMS_FOLDER="$CURRENT_DIR/IaC/build-pipeline/bicep/env-params"

      echo "Looking for parameters in: $PARAMS_FOLDER"

      # Map the destination branch to the correct parameters JSON file
      case "$DEST_BRANCH" in
        "dev")
          PARAMS_FILE="$PARAMS_FOLDER/dev.parameters.json"
          ;;
        "staging")
          PARAMS_FILE="$PARAMS_FOLDER/qa.parameters.json"
          ;;
        "main")
          PARAMS_FILE="$PARAMS_FOLDER/prod.parameters.json"
          ;;
        *)
          echo "ðŸš« No matching destination branch found. Using default dev.parameters.json"
          PARAMS_FILE="$PARAMS_FOLDER/dev.parameters.json"
          ;;
      esac

      echo "âœ… Using parameters file: $PARAMS_FILE"

      # Ensure the parameters file exists
      if [ ! -f "$PARAMS_FILE" ]; then
          echo "âš ï¸ Error: Parameters file $PARAMS_FILE not found!"
          exit 1
      fi

      # Extract values from the JSON file using jq
      NEXT_PUBLIC_API_BASE_URL=$(jq -r '.parameters.webApiBaseUrl.value' $PARAMS_FILE)
      NEXT_PUBLIC_SITE_URL=$(jq -r '.parameters.webApiBaseUrl.value' $PARAMS_FILE)

      NEXT_PUBLIC_NODE_ENV=$(jq -r '.parameters.nodeEnv.value' $PARAMS_FILE)

      NEXT_PUBLIC_FIREBASE_API_KEY=$(jq -r '.parameters.firebaseApiKey.value' $PARAMS_FILE)
      NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=$(jq -r '.parameters.firebaseAuthDomain.value' $PARAMS_FILE)
      NEXT_PUBLIC_FIREBASE_DATABASE_URL=$(jq -r '.parameters.firebaseDatabaseUrl.value' $PARAMS_FILE)
      NEXT_PUBLIC_FIREBASE_PROJECT_ID=$(jq -r '.parameters.firebaseProjectId.value' $PARAMS_FILE)
      NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=$(jq -r '.parameters.firebaseStorageBucket.value' $PARAMS_FILE)
      NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=$(jq -r '.parameters.firebaseMessageSenderId.value' $PARAMS_FILE)
      NEXT_PUBLIC_FIREBASE_APP_ID=$(jq -r '.parameters.firebaseAppId.value' $PARAMS_FILE)
      NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID=$(jq -r '.parameters.firebaseMeasurementId.value' $PARAMS_FILE)
      NEXT_PUBLIC_GOOGLE_MAP_API_KEY=$(jq -r '.parameters.googleMapApiKey.value' $PARAMS_FILE)

      echo "API_BASE_URL: $NEXT_PUBLIC_API_BASE_URL"


      # Ensure values are not empty before writing to .env
      if [[ -z "$NEXT_PUBLIC_API_BASE_URL" || -z "$NEXT_PUBLIC_SITE_URL" ]]; then
          echo "âš ï¸ Error: One or more required parameters are missing in $PARAMS_FILE"
          exit 1
      fi

      # Write extracted values to .env file
      echo "Setting up environment for $DEST_BRANCH branch..."

      echo "NEXT_PUBLIC_API_BASE_URL=$NEXT_PUBLIC_API_BASE_URL" >> .env
      echo "NEXT_PUBLIC_SITE_URL=$NEXT_PUBLIC_SITE_URL" >> .env


      echo "NEXT_PUBLIC_FIREBASE_API_KEY=$NEXT_PUBLIC_FIREBASE_API_KEY" >> .env
      echo "NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=$NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN" >> .env
      echo "NEXT_PUBLIC_FIREBASE_DATABASE_URL=$NEXT_PUBLIC_FIREBASE_DATABASE_URL" >> .env
      echo "NEXT_PUBLIC_FIREBASE_PROJECT_ID=$NEXT_PUBLIC_FIREBASE_PROJECT_ID" >> .env
      echo "NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=$NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET" >> .env
      echo "NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=$NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID" >> .env
      echo "NEXT_PUBLIC_FIREBASE_APP_ID=$NEXT_PUBLIC_FIREBASE_APP_ID" >> .env
      echo "NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID=$NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID" >> .env
      echo "NEXT_PUBLIC_GOOGLE_MAP_API_KEY=$NEXT_PUBLIC_GOOGLE_MAP_API_KEY" >> .env
      echo "NEXT_PUBLIC_NODE_ENV=$NEXT_PUBLIC_NODE_ENV" >> .env

      echo "âœ… Environment setup completed for branch: $DEST_BRANCH"

    displayName: "Setup Environment Variables (Using Destination Branch)"
  # Extract version and set pipeline variable
  - script: |
      VERSION=$(jq -r '.version' package.json)
      BRANCH_NAME=$(Build.SourceBranchName)
      if [ "$BRANCH_NAME" == "dev" ]; then
        VERSION_TAG="$VERSION-dev"
      elif [ "$BRANCH_NAME" == "staging" ]; then
        VERSION_TAG="$VERSION-staging"
      elif [ "$BRANCH_NAME" == "main" ] || [ "$BRANCH_NAME" == "prod" ]; then
        VERSION_TAG="$VERSION"
      else
        VERSION_TAG="$VERSION-unknown"
      fi

      echo "##vso[task.setvariable variable=VERSION_TAG;isOutput=true]$VERSION_TAG"
      echo "Docker Image Tag: $VERSION_TAG"
      echo "$VERSION_TAG" > $(Build.ArtifactStagingDirectory)/version.txt
    name: SetVersion
    displayName: "Extract Version and Set Pipeline Variable"

  # Publish the VERSION_TAG as an artifact
  - task: PublishBuildArtifacts@1
    displayName: "Publish Version Artifact"
    inputs:
      pathToPublish: "$(Build.ArtifactStagingDirectory)/version.txt"
      artifactName: ${{ parameters.ARTIFACT_NAME }}
      publishLocation: "Container"

  # Docker Build (for branches other than dev, staging, main)
  - task: Docker@2
    condition: and(succeeded(), not(or(eq(variables['Build.SourceBranchName'], 'dev'), eq(variables['Build.SourceBranchName'], 'staging'), eq(variables['Build.SourceBranchName'], 'main'))))
    displayName: "Docker Build (Other Branches)"
    inputs:
      command: "build"
      repository: "fennecapp-web"
      dockerfile: "$(Build.SourcesDirectory)/Dockerfile"
      buildContext: "$(Build.SourcesDirectory)"
      tags: "$(SetVersion.VERSION_TAG)"

  # Docker Build and Push for Dev Branch
  - task: Docker@2
    condition: eq(variables['Build.SourceBranchName'], 'dev')
    displayName: "Docker Build and Push (Dev)"
    inputs:
      command: "buildAndPush"
      repository: "fennecapp-web"
      dockerfile: "$(Build.SourcesDirectory)/Dockerfile"
      buildContext: "$(Build.SourcesDirectory)"
      tags: "$(SetVersion.VERSION_TAG)"
      containerRegistry: "acr-service-connection"

  # Docker Build and Push for Staging Branch
  - task: Docker@2
    condition: eq(variables['Build.SourceBranchName'], 'staging')
    displayName: "Docker Build and Push (Staging)"
    inputs:
      command: "buildAndPush"
      repository: "fennecapp-web"
      dockerfile: "$(Build.SourcesDirectory)/Dockerfile"
      buildContext: "$(Build.SourcesDirectory)"
      tags: "$(SetVersion.VERSION_TAG)"
      containerRegistry: "acr-service-connection"

  # Docker Build and Push for Main Branch (With Latest Tag)
  - task: Docker@2
    condition: eq(variables['Build.SourceBranchName'], 'main')
    displayName: "Docker Build and Push (Main)"
    inputs:
      command: "buildAndPush"
      repository: "fennecapp-web"
      dockerfile: "$(Build.SourcesDirectory)/Dockerfile"
      buildContext: "$(Build.SourcesDirectory)"
      tags: "$(SetVersion.VERSION_TAG),latest"
      containerRegistry: "acr-service-connection"

  # Build Bicep File
  - task: AzureCLI@2
    displayName: "Build Bicep File into main.json"
    inputs:
      azureSubscription: "azure-connect"
      scriptType: "bash"
      scriptLocation: "inlineScript"
      inlineScript: |
        BICEP_PATH="$(Build.SourcesDirectory)/${{ parameters.BICEP_FILE_LOCATION }}"
        echo "Building Bicep file: $BICEP_PATH/main.bicep"

        if ! az bicep build --file "$BICEP_PATH/main.bicep" --outfile main.json; then
          echo "Bicep validation failed."
          exit 1
        else
          echo "Bicep build successful."
        fi

        echo "Copying parameter files..."
        mkdir -p params
        cp $BICEP_PATH/env-params/*.json params/
        echo "Parameter files copied."

        echo "Moving files to $(Build.ArtifactStagingDirectory)..."
        mkdir -p $(Build.ArtifactStagingDirectory)/params
        mv main.json $(Build.ArtifactStagingDirectory)
        cp -r params/* $(Build.ArtifactStagingDirectory)/params
        echo "Files moved to staging directory."

  # Publish Bicep artifacts
  - task: PublishBuildArtifacts@1
    displayName: "Publish main.json and params as Artifact"
    inputs:
      pathToPublish: "$(Build.ArtifactStagingDirectory)"
      artifactName: ${{ parameters.ARTIFACT_NAME }}
      publishLocation: "Container"